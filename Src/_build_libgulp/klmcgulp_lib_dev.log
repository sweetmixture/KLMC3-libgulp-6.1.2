#
#   Author:         Woongkyu Jee / woong.jee.16@ucl.ac.uk
#   Affiliation:    University College London
#   Date:           2023.05.25 - 
#
# -----------------------------------------------------   
#   KLMC3 - GULP library development log
#
#   To build GULP library for KLMC3, run scripts:
#
#   ARCHER2 : cray_compile.sh
#   YOUNG   : intel_compile.sh
#
# -----------------------------------------------------   
#
	1. 07.2023 WKJEE. first libridisation
	
	2. 06.2024 WKJEE. memory leaking fix

		! new subroutine: 'gulpklmc_deallocate_all.F90' added

			[a] any allocatables in 'modules.F90' are forced to be deallocated
			    * this subroutine will be called always at the end of 'gulpklmc()' to clean up

			[b] in 'initmemory.F90', 'subroutine initmemory()'

				* module 'm_gfnff_nbr3' (m_gfnff_nbr3.F90) 
					allocatables are forced to be deallocated, as a part of 'gulpklmc_deallocate_all.F90'
				* module 'kim_models' (modules_kim.F90)
					allocatables are forced to be deallocated, as a part of 'gulpklmc_deallocate_all.F90'
				* module 'm_pr' (m_pr.F90)
					allocatables are forced to be deallocated, as a part of 'gulpklmc_deallocate_all.F90'
				* module 'm_pdfneutron' (m_pdfneutron.F90)
					allocatables are forced to be deallocated, as a part of 'gulpklmc_deallocate_all.F90' : only pointers will be deallocated (allocatables not touched)
			
			[c] N.B. other allocatables in 'modules'

				e.g., 'kim_functions' (kim_functions.F90), any m_*.F90 files have not been explicitly touched
				* require further development (remember: associated can only be used for pointers, allocatalbe -> use allocated() )

		! in GULP source code level: 'optim.F90', at the end of 'subroutine optim()' is modified for KLMC3 use.

			[a] in block #ifdef KLMC3 ~ #end
				* local allocatable 'hess' is forced to be deallocated, when it is used as a part of KLMC.

	*
	*	copy of 'gulpklmc_deallocate_all.F90' is at dir: ./gulpklmc_memoryleak_fix.06.2024
	*

	3. 07.2024 WKJEE.

		!
		! BLACS communicator leaking fix
		!
			[a] This has been related to the following error
	
			'MPIR_Get_contextid_sparse_group(610): Too many communicators (0/2048 free on this process; ignore_id=0)'

			encountered when 'gulpmain()' called 512 times on ARCHER 2

			* Issue:
				CALL BLACS_GRIDINIT(CONTEXT): 'initcomm.F90', which never freed.
				CONTEXT: typically a MPI_Comm handle

			-> solution: added to 'gulpklmc_deallocate_all.F90' under 'module parallel'

				CALL BLACS_GRIDEXIT(CONTEXT):
				CONTEXT consume resources, and therefore CONTEXT should be released when no longer needed. 
				After the freeing of a context, the context no longer exists,
				* * * and its handle may be re-used if new contexts are defined. * * *
				Note. CALL BLACS_EXIT(CONTEXT): this will destroy CONTEXT, and the CONTEXT no longer available.
				(i.e., the MPI_Comm passed to Context will no longer be available)

			* 'BLACS_GRIDINIT' used in other subroutines: 'eigensolve_elpa.F90', 'pdiagd.F90', 'pdiaggd.F90',
			  and they are followed by 'BLACS_GRIDEXIT'

		!
		! Catching abnormal gulpfinish
		!
			* Core-Shell abnormal distance invoke gulpfinish (by 07.2024), this is managed by keep calling return.
			  (not ideal solution, but can deal with this by adding 'stepmx' option word in GULP input files)

			- Call stack of 'core-shell' distance: this check is done by 'cutscheck()' subroutine (in cutscheck.F90)

			+ 128 gulpklmc
				+ 128 gulpmain
					+ 128 gulp_options
						+ 128 optim
							+ 384 funct
								+ 384 cutscheck

				gulpklmc()      | gulpklmc.F90 : gulpmain() wrapper for KLMC3
				gulpmain()      | gulpmain.F90
				gulp_options()  | options.F90
				optim()         | optim.F90
				funct()         | funct.F90
				cutscheck()     | cutscheck.F90

			> implementation of backtracing to 'gulpmain' has not been done.


