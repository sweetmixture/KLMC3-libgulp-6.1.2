#
#   Author:         Woongkyu Jee / woong.jee.16@ucl.ac.uk
#   Affiliation:    University College London
#   Date:           2023.05.25 - 
#
# -----------------------------------------------------   
#   KLMC3 - GULP library development log
#
#   To build GULP library for KLMC3, run scripts:
#
#   ARCHER2 : cray_compile.sh
#   YOUNG   : intel_compile.sh
#
# -----------------------------------------------------   
#
	1. 07.2023 WKJEE. first libridisation
	
	2. 06.2024 WKJEE. memory leaking fix

		! new subroutine: 'gulpklmc_deallocate_all.F90' added

			[a] any allocatables in 'modules.F90' are forced to be deallocated
			    * this subroutine will be called always at the end of 'gulpklmc()' to clean up

			[b] in 'initmemory.F90', 'subroutine initmemory()'

				* module 'm_gfnff_nbr3' (m_gfnff_nbr3.F90) 
					allocatables are forced to be deallocated, as a part of 'gulpklmc_deallocate_all.F90'
				* module 'kim_models' (modules_kim.F90)
					allocatables are forced to be deallocated, as a part of 'gulpklmc_deallocate_all.F90'
				* module 'm_pr' (m_pr.F90)
					allocatables are forced to be deallocated, as a part of 'gulpklmc_deallocate_all.F90'
				* module 'm_pdfneutron' (m_pdfneutron.F90)
					allocatables are forced to be deallocated, as a part of 'gulpklmc_deallocate_all.F90' : only pointers will be deallocated (allocatables not touched)
			
			[c] N.B. other allocatables in 'modules'

				e.g., 'kim_functions' (kim_functions.F90), any m_*.F90 files have not been explicitly touched
				* require further development (remember: associated can only be used for pointers, allocatalbe -> use allocated() )

		! in GULP source code level: 'optim.F90', at the end of 'subroutine optim()' is modified for KLMC3 use.

			[a] in block #ifdef KLMC3 ~ #end
				* local allocatable 'hess' is forced to be deallocated, when it is used as a part of KLMC.

	*
	*	copy of 'gulpklmc_deallocate_all.F90' is at dir: ./gulpklmc_memoryleak_fix.06.2024
	*

	3. 07.2024 WKJEE.

		!
		! BLACS communicator leaking fix
		!
			[a] This has been related to the following error
	
			'MPIR_Get_contextid_sparse_group(610): Too many communicators (0/2048 free on this process; ignore_id=0)'

			encountered when 'gulpmain()' called 512 times on ARCHER 2

			* Issue:
				CALL BLACS_GRIDINIT(CONTEXT): 'initcomm.F90', which never freed.
				CONTEXT: typically a MPI_Comm handle

			-> solution: added to 'gulpklmc_deallocate_all.F90' under 'module parallel'

				CALL BLACS_GRIDEXIT(CONTEXT):
				CONTEXT consume resources, and therefore CONTEXT should be released when no longer needed. 
				After the freeing of a context, the context no longer exists,
				* * * and its handle may be re-used if new contexts are defined. * * *
				Note. CALL BLACS_EXIT(CONTEXT): this will destroy CONTEXT, and the CONTEXT no longer available.
				(i.e., the MPI_Comm passed to Context will no longer be available)

			* 'BLACS_GRIDINIT' used in other subroutines: 'eigensolve_elpa.F90', 'pdiagd.F90', 'pdiaggd.F90',
			  and they are followed by 'BLACS_GRIDEXIT'


	4. 10.2024 WKJEE.

		!
		! Catching abnormal gulpfinish
		!
			* Core-Shell abnormal distance invoke 'stopnow() or gulpfinish()', direct to call 'stop' and crash gulp-lib.

			  Before this point, 'stop' was replaced to 'return' and, for instance, gulp-lib was hanging until the end of optimisation cycle.

			  Other possible solution:

			  [1] core-shell breaking incident can be eased by including 'stepmx' option work in GULP input files,
			      which constrains the maximul atom moving step size during line minimisation.


			* SCORE-P investigation result on ARCHER2

			+ 128 gulpklmc
				+ 128 gulpmain
					+ 128 gulp_options
						+ 128 optim
							+ 384 funct
								+ 384 cutscheck

				gulpklmc()      | gulpklmc.F90 : gulpmain() wrapper for KLMC3
				gulpmain()      | gulpmain.F90
				gulp_options()  | options.F90
				optim()         | optim.F90
				funct()         | funct.F90
				cutscheck()     | cutscheck.F90

			here 'cutscheck()' subroutine is resposible for the core-shell distance, verifying whether it is broken.

			> subroutine 'funct()' does many types of energy, force, etc related measurements, including 'custcheck()'.

			  KEY: ONLY 'funct()' CALL 'cutscheck()' SUBROUTINE

			* Possible call stack of a standard energy minimisaton:

			...
				+ gulp_options()                                             : options.F90
					...
					+ optim()                                                : optim.F90    optimisation, note. defect calculation is seperated as defopt() in defopt.F90
						+ funct()                                            : funct.F90    energy, derivative ... including 'cutscheck()'
						+ functn()                                           : functn.F90   energy, numerical derivative ... including funct()
							+ funct()
							+ stopnow()                                      : stopnow.F90  forcing exit, this is detected by KLMC3
						+ minimise()
							+ funct()
							+ functn()
								+ funct()
							+ olinmin()                                      : olinmin.F90  line minimiser
								+ funct()
						+ harmonicrelax()
							+ funct()
							+ stopnow()

			^^^^^^^^^^^^^^^^^^^^^^^^^^^^ listing the possible edge cases covered by this hotfix, catching core-shell error

			> Changes were made for the following GULP source files

			modules.F90                           : in module klmc, a logical type 'lklmc_return_gulp' is added as a flag to return GULP.

			initial.F90                           : initialising 'lklmc_return_gulp'
			stopnow.F90
			cutscheck.F90
			funct.F90
			functn.F90
			olinmin.F90
			finish.F90
			harmonicrelax.F90
			minimise.F90
			optim.F90

		* Update tested

			[1] Multiple gulpmain() calls tested

			[2] Calling gulpmain() in KLMC3 interface tested: /work/e05/e05/wkjee/Masters/Zirui2023/MnO/shelOnly/li3/_testrun_core_shell_fix


		* Possible output of core-shell breaking is:

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!! ERROR : Largest core-shell distance exceeds cutoff of cuts
			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			
			
			  Largest core-shell distance =   1.7167 Angstroms
			
			
			 Program terminated by processor     0 in            cutscheck
			
			 * KLMC detected abnormal exit
			 > KLMC_MESSAGE : _KLMC_GULP_EXIT_ : subroutine stopnow() : stopnow.F90
			 > KLMC_MESSAGE : call stack : subroutine cutscheck() > see cutscheck.F90
			 > KLMC_MESSAGE : call stack : subroutine funct() > see funct.F90
			 > KLMC_MESSAGE : call stack : subroutine olinmin() > see olinmin.F90 : invoked after funct() : 3
			 > KLMC_MESSAGE : call stack : subroutine minimise() > see minimise.F90 : invoked after olinmin() : 1
			 > KLMC_MESSAGE : call stack : subroutine optim() > see optim.F90 : invoked after minimise() : 2
			 > KLMC_MESSAGE : call stack : subroutine optim() > see optim.F90 : before return : abnormal KLMC < GULP return


			If user is using a custom post-processing script, this could be dected by searching '_KLMC_GULP_EXIT_' string in GULP standard output files.


